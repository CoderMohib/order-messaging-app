import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/message_model.dart';

class MessageRepository {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  static const String _collectionName = 'messages';
  static const String _orderTakerId = 'order_taker'; // Fixed ID for Order Taker

  // Send a message to Order Taker
  Future<void> sendMessage(String text) async {
    try {
      final currentUser = _auth.currentUser;
      if (currentUser == null) {
        throw Exception('User not authenticated');
      }

      if (text.trim().isEmpty) {
        throw Exception('Message cannot be empty');
      }

      final message = Message(
        id: '', // Will be generated by Firestore
        text: text.trim(),
        senderId: currentUser.uid,
        receiverId: _orderTakerId,
        senderName: currentUser.email ?? currentUser.uid,
        timestamp: DateTime.now(),
      );

      await _firestore.collection(_collectionName).add(message.toFirestore());
    } catch (e) {
      throw Exception('Failed to send message: ${e.toString()}');
    }
  }

  // Get real-time stream of messages (both sent and received)
  Stream<List<Message>> getMessagesStream() {
    try {
      final currentUser = _auth.currentUser;
      if (currentUser == null) {
        return Stream.value([]);
      }

      // Get messages where user is sender and Order Taker is receiver
      final sentMessages = _firestore
          .collection(_collectionName)
          .where('senderId', isEqualTo: currentUser.uid)
          .where('receiverId', isEqualTo: _orderTakerId)
          .orderBy('timestamp', descending: false)
          .snapshots();

      // Get messages where Order Taker is sender and user is receiver
      final receivedMessages = _firestore
          .collection(_collectionName)
          .where('senderId', isEqualTo: _orderTakerId)
          .where('receiverId', isEqualTo: currentUser.uid)
          .orderBy('timestamp', descending: false)
          .snapshots();

      // Combine both streams manually
      final controller = StreamController<List<Message>>.broadcast();
      final sentList = <Message>[];
      final receivedList = <Message>[];
      
      void emitCombined() {
        final allMessages = <Message>[];
        allMessages.addAll(sentList);
        allMessages.addAll(receivedList);
        allMessages.sort((a, b) => a.timestamp.compareTo(b.timestamp));
        if (!controller.isClosed) {
          controller.add(allMessages);
        }
      }
      
      StreamSubscription? sentSubscription;
      StreamSubscription? receivedSubscription;
      
      sentSubscription = sentMessages.listen(
        (snapshot) {
          sentList.clear();
          sentList.addAll(
            snapshot.docs.map((doc) => Message.fromFirestore(doc)),
          );
          emitCombined();
        },
        onError: (error) {
          if (!controller.isClosed) {
            controller.addError(error);
          }
        },
      );
      
      receivedSubscription = receivedMessages.listen(
        (snapshot) {
          receivedList.clear();
          receivedList.addAll(
            snapshot.docs.map((doc) => Message.fromFirestore(doc)),
          );
          emitCombined();
        },
        onError: (error) {
          if (!controller.isClosed) {
            controller.addError(error);
          }
        },
      );
      
      // Close controller and cancel subscriptions when stream is cancelled
      controller.onCancel = () {
        sentSubscription?.cancel();
        receivedSubscription?.cancel();
        controller.close();
      };
      
      return controller.stream;
    } catch (e) {
      throw Exception('Failed to load messages: ${e.toString()}');
    }
  }

  // Get Order Taker ID (for UI display purposes)
  String getOrderTakerId() {
    return _orderTakerId;
  }
}

